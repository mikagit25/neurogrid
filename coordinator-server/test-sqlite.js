#!/usr/bin/env node

/**
 * SQLite Test Script for New Database Models
 * –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–æ–≤—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ —Å SQLite
 */

require('dotenv').config();
const UserServiceSQLite = require('./src/services/UserServiceSQLite');
const { db, initializeDatabase } = require('./src/config/sqlite');
const logger = require('./src/utils/logger');

// –¶–≤–µ—Ç–∞ –¥–ª—è –∫–æ–Ω—Å–æ–ª–∏
const colors = {
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  reset: '\x1b[0m',
  bold: '\x1b[1m'
};

function colorLog(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

class SQLiteTestSuite {
  constructor() {
    this.name = 'SQLiteTestSuite';
  }

  async initializeDatabase() {
    try {
      await initializeDatabase();
      colorLog('‚úÖ SQLite database initialized', 'green');
      return true;
    } catch (error) {
      colorLog(`‚ùå Database initialization failed: ${error.message}`, 'red');
      return false;
    }
  }

  async testDatabaseConnection() {
    try {
      const result = await UserServiceSQLite.testConnection();
      
      if (result.success) {
        colorLog('‚úÖ Database connection successful', 'green');
        console.log(`   Database: ${result.database}`);
        console.log(`   Timestamp: ${result.timestamp}`);
        return true;
      } else {
        colorLog(`‚ùå Database connection failed: ${result.error}`, 'red');
        return false;
      }
    } catch (error) {
      colorLog(`‚ùå Connection test error: ${error.message}`, 'red');
      return false;
    }
  }

  async checkRequiredTables() {
    try {
      const requiredTables = [
        'users',
        'user_balances',
        'transactions',
        'nodes',
        'jobs'
      ];

      const results = {};

      for (const table of requiredTables) {
        const result = await db.query(`
          SELECT name FROM sqlite_master 
          WHERE type='table' AND name=?
        `, [table]);
        
        results[table] = result.rows.length > 0;
      }

      colorLog('üìã Table existence check:', 'blue');
      Object.entries(results).forEach(([table, exists]) => {
        console.log(`   ${table}: ${exists ? '‚úÖ' : '‚ùå'}`);
      });

      return results;

    } catch (error) {
      colorLog(`‚ùå Error checking tables: ${error.message}`, 'red');
      return null;
    }
  }

  async createTestUser() {
    try {
      const testEmail = 'test@neurogrid.local';
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ —Ç–µ—Å—Ç–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
      const existing = await UserServiceSQLite.findByEmail(testEmail);
      if (existing) {
        colorLog('‚ö†Ô∏è  Test user already exists, using existing', 'yellow');
        return existing;
      }

      // –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      const testUser = await UserServiceSQLite.create({
        username: 'testuser',
        email: testEmail,
        password: 'TestPassword123',
        role: 'user'
      });

      colorLog('‚úÖ Test user created successfully', 'green');
      console.log(`   User ID: ${testUser.id}`);
      console.log(`   Email: ${testUser.email}`);

      return testUser;

    } catch (error) {
      colorLog(`‚ùå Error creating test user: ${error.message}`, 'red');
      throw error;
    }
  }

  async testUserAuthentication() {
    try {
      const testEmail = 'test@neurogrid.local';
      const testPassword = 'TestPassword123';

      const result = await UserServiceSQLite.verifyPassword(testEmail, testPassword);
      
      if (result.success) {
        colorLog('‚úÖ User authentication successful', 'green');
        return true;
      } else {
        colorLog(`‚ùå Authentication failed: ${result.error}`, 'red');
        return false;
      }

    } catch (error) {
      colorLog(`‚ùå Authentication test error: ${error.message}`, 'red');
      return false;
    }
  }

  async testTransactionCreation() {
    try {
      const testEmail = 'test@neurogrid.local';
      const user = await UserServiceSQLite.findByEmail(testEmail);
      
      if (!user) {
        throw new Error('Test user not found');
      }

      // –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—É—é —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
      const result = await db.query(`
        INSERT INTO transactions (user_id, transaction_type, amount, description, status)
        VALUES (?, ?, ?, ?, ?)
      `, [user.id, 'credit', 100.00, 'Test deposit transaction', 'completed']);

      colorLog('‚úÖ Test transaction created successfully', 'green');
      console.log(`   Transaction ID: ${result.lastID}`);
      console.log(`   Amount: $100.00`);

      return { id: result.lastID, amount: 100.00 };

    } catch (error) {
      colorLog(`‚ùå Transaction creation failed: ${error.message}`, 'red');
      throw error;
    }
  }

  async testProfileUpdate() {
    try {
      const testEmail = 'test@neurogrid.local';
      const user = await UserServiceSQLite.findByEmail(testEmail);
      
      if (!user) {
        throw new Error('Test user not found');
      }

      const updatedUser = await UserServiceSQLite.updateProfile(user.id, {
        profile: {
          displayName: 'Test User',
          bio: 'This is a test user profile'
        }
      });

      colorLog('‚úÖ Profile update successful', 'green');
      console.log(`   Profile updated for: ${updatedUser.username}`);

      return updatedUser;

    } catch (error) {
      colorLog(`‚ùå Profile update failed: ${error.message}`, 'red');
      throw error;
    }
  }

  async testUserStats() {
    try {
      const testEmail = 'test@neurogrid.local';
      const user = await UserServiceSQLite.findByEmail(testEmail);
      
      if (!user) {
        throw new Error('Test user not found');
      }

      const stats = await UserServiceSQLite.getStats(user.id);

      colorLog('‚úÖ User stats retrieved successfully', 'green');
      console.log(`   Total jobs: ${stats.total_jobs}`);
      console.log(`   Balance: $${stats.balance}`);
      console.log(`   Total earned: $${stats.total_earned}`);

      return stats;

    } catch (error) {
      colorLog(`‚ùå Stats retrieval failed: ${error.message}`, 'red');
      throw error;
    }
  }

  async runFullTest() {
    try {
      colorLog('\n=== SQLite Database Models Test ===', 'bold');
      colorLog('Starting comprehensive test with SQLite...', 'blue');

      // 1. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
      const initOk = await this.initializeDatabase();
      if (!initOk) {
        throw new Error('Database initialization failed');
      }

      // 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
      const connectionOk = await this.testDatabaseConnection();
      if (!connectionOk) {
        throw new Error('Database connection failed');
      }

      // 3. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∞–±–ª–∏—Ü
      const tables = await this.checkRequiredTables();
      if (!tables) {
        throw new Error('Failed to check required tables');
      }

      // 4. –°–æ–∑–¥–∞–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      const testUser = await this.createTestUser();

      // 5. –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
      const authOk = await this.testUserAuthentication();
      if (!authOk) {
        throw new Error('Authentication test failed');
      }

      // 6. –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
      const testTransaction = await this.testTransactionCreation();

      // 7. –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—Ä–æ—Ñ–∏–ª—è
      const profileUpdate = await this.testProfileUpdate();

      // 8. –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
      const userStats = await this.testUserStats();

      colorLog('\nüéâ All tests passed successfully!', 'green');

      return {
        success: true,
        results: {
          initialization: initOk,
          connection: connectionOk,
          tables,
          user: testUser,
          authentication: authOk,
          transaction: testTransaction,
          profileUpdate,
          userStats
        }
      };

    } catch (error) {
      colorLog(`\nüí• Test suite failed: ${error.message}`, 'red');
      return {
        success: false,
        error: error.message
      };
    }
  }

  async cleanupTestData() {
    try {
      const testEmail = 'test@neurogrid.local';
      const user = await UserServiceSQLite.findByEmail(testEmail);
      
      if (!user) {
        colorLog('‚ö†Ô∏è  No test user found to cleanup', 'yellow');
        return;
      }

      // –£–¥–∞–ª—è–µ–º —Å–≤—è–∑–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ (SQLite —É–¥–∞–ª–∏—Ç —á–µ—Ä–µ–∑ CASCADE)
      await db.query('DELETE FROM users WHERE email = ?', [testEmail]);
      
      colorLog('‚úÖ Test data cleaned up successfully', 'green');

    } catch (error) {
      colorLog(`‚ùå Cleanup failed: ${error.message}`, 'red');
      throw error;
    }
  }
}

async function runTest() {
  const suite = new SQLiteTestSuite();
  const result = await suite.runFullTest();

  if (result.success) {
    console.log('\nüìä Test Summary:');
    console.log('- Database Initialization:', result.results.initialization ? '‚úÖ' : '‚ùå');
    console.log('- Connection Test:', result.results.connection ? '‚úÖ' : '‚ùå');
    console.log('- User Creation:', result.results.user ? '‚úÖ' : '‚ùå');
    console.log('- Authentication:', result.results.authentication ? '‚úÖ' : '‚ùå');
    console.log('- Transaction Creation:', result.results.transaction ? '‚úÖ' : '‚ùå');
    console.log('- Profile Update:', result.results.profileUpdate ? '‚úÖ' : '‚ùå');
    console.log('- User Stats:', result.results.userStats ? '‚úÖ' : '‚ùå');

    colorLog('\nüöÄ Next Steps:', 'blue');
    console.log('1. Run "node test-sqlite.js cleanup" to clean test data');
    console.log('2. Integrate SQLite service into your main application');
    console.log('3. When ready, migrate to PostgreSQL for production');
  } else {
    process.exit(1);
  }
}

async function runCleanup() {
  const suite = new SQLiteTestSuite();
  await suite.initializeDatabase();
  await suite.cleanupTestData();
}

async function showInfo() {
  colorLog('\n=== SQLite Database Implementation ===', 'bold');
  
  colorLog('\nüí° About this implementation:', 'blue');
  console.log('- Uses SQLite3 for local development');
  console.log('- Compatible with existing PostgreSQL schema');
  console.log('- Includes all NeuroGrid user management features');
  console.log('- Easy migration path to PostgreSQL');
  
  colorLog('\nüìÅ Database location:', 'blue');
  console.log('- File: coordinator-server/data/neurogrid.db');
  console.log('- Auto-created on first run');
  
  colorLog('\nüîß Available features:', 'blue');
  console.log('‚úÖ User registration and authentication');
  console.log('‚úÖ Password hashing with bcrypt');
  console.log('‚úÖ User profiles and settings');
  console.log('‚úÖ Transaction tracking');
  console.log('‚úÖ Node management (tables ready)');
  console.log('‚úÖ Job management (tables ready)');
  
  colorLog('\n‚ö° Performance notes:', 'blue');
  console.log('- SQLite is single-threaded but very fast for dev');
  console.log('- Perfect for testing and small deployments');
  console.log('- Easy backup (just copy the .db file)');
}

function showHelp() {
  colorLog('\n=== SQLite Database Test Script ===', 'bold');
  console.log('\nAvailable commands:');
  console.log('  test       - Run full test suite');
  console.log('  cleanup    - Clean up test data');
  console.log('  info       - Show implementation info');
  console.log('  help       - Show this help message');
  console.log('\nExamples:');
  console.log('  node test-sqlite.js test');
  console.log('  node test-sqlite.js cleanup');
}

async function main() {
  const command = process.argv[2] || 'test';

  process.env.LOG_LEVEL = process.env.LOG_LEVEL || 'info';

  switch (command) {
    case 'test':
      await runTest();
      break;
    
    case 'cleanup':
      await runCleanup();
      break;
    
    case 'info':
      await showInfo();
      break;
    
    case 'help':
      showHelp();
      break;
    
    default:
      colorLog(`‚ùå Unknown command: ${command}`, 'red');
      showHelp();
      process.exit(1);
  }

  // –ó–∞–∫—Ä—ã–≤–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö
  try {
    await db.close();
  } catch (error) {
    // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏
  }

  colorLog('\nTest completed! üéâ', 'green');
}

process.on('unhandledRejection', (reason, promise) => {
  colorLog(`\nüí• Unhandled Rejection: ${reason}`, 'red');
  process.exit(1);
});

process.on('uncaughtException', (error) => {
  colorLog(`\nüí• Uncaught Exception: ${error.message}`, 'red');
  process.exit(1);
});

main().catch((error) => {
  colorLog(`\nüí• Script failed: ${error.message}`, 'red');
  console.error(error);
  process.exit(1);
});