/**\n * Redis-based Caching Layer for NeuroGrid\n * Provides intelligent caching with automatic invalidation and warm-up strategies\n */\n\nconst Redis = require('ioredis'); \nconst logger = require('../utils/logger'); \nconst { createHash } = require('crypto'); \n\nclass CacheManager { \n    constructor(options = {}) { \n        this.config = { \n            host: options.host || process.env.REDIS_HOST || 'localhost', \n            port: options.port || process.env.REDIS_PORT || 6379, \n            password: options.password || process.env.REDIS_PASSWORD, \n            db: options.db || process.env.REDIS_DB || 0, \n            keyPrefix: options.keyPrefix || 'neurogrid:', \n            defaultTTL: options.defaultTTL || 3600, // 1 hour\n            maxRetries: options.maxRetries || 3,\n            retryDelayOnFailover: options.retryDelayOnFailover || 100,\n            enableOfflineQueue: options.enableOfflineQueue !== false,\n            lazyConnect: options.lazyConnect !== false,\n            ...options\n        };\n\n        // Cache tiers with different TTLs\n        this.tiers = {\n            hot: { ttl: 300, prefix: 'hot:' },        // 5 minutes - frequently accessed\n            warm: { ttl: 1800, prefix: 'warm:' },    // 30 minutes - regularly accessed\n            cold: { ttl: 7200, prefix: 'cold:' },    // 2 hours - occasionally accessed\n            persistent: { ttl: 86400, prefix: 'persist:' } // 24 hours - rarely changing\n        };\n\n        this.redis = null;\n        this.fallbackCache = new Map(); // In-memory fallback\n        this.connected = false;\n        this.stats = {\n            hits: 0,\n            misses: 0,\n            sets: 0,\n            deletes: 0,\n            errors: 0,\n            fallbackHits: 0\n        };\n\n        this.initialize();\n    }\n\n    /**\n     * Initialize Redis connection\n     */\n    async initialize() {\n        try {\n            this.redis = new Redis({\n                host: this.config.host,\n                port: this.config.port,\n                password: this.config.password,\n                db: this.config.db,\n                keyPrefix: this.config.keyPrefix,\n                maxRetriesPerRequest: this.config.maxRetries,\n                retryDelayOnFailover: this.config.retryDelayOnFailover,\n                enableOfflineQueue: this.config.enableOfflineQueue,\n                lazyConnect: this.config.lazyConnect\n            });\n\n            this.redis.on('connect', () => {\n                this.connected = true;\n                logger.info('Cache manager connected to Redis', {\n                    host: this.config.host,\n                    port: this.config.port,\n                    db: this.config.db\n                });\n            });\n\n            this.redis.on('error', (error) => {\n                this.connected = false;\n                this.stats.errors++;\n                logger.error('Redis connection error', { error });\n            });\n\n            this.redis.on('close', () => {\n                this.connected = false;\n                logger.warn('Redis connection closed');\n            });\n\n            this.redis.on('reconnecting', (ms) => {\n                logger.info('Redis reconnecting', { delay: ms });\n            });\n\n            // Test connection\n            if (this.config.lazyConnect) {\n                await this.redis.ping();\n            }\n\n            // Start cleanup interval\n            this.startCleanupInterval();\n\n        } catch (error) {\n            logger.error('Failed to initialize cache manager', { error });\n            this.connected = false;\n        }\n    }\n\n    /**\n     * Get value from cache\n     */\n    async get(key, options = {}) {\n        const { tier = 'warm', deserialize = true } = options;\n        const fullKey = this.buildKey(key, tier);\n\n        try {\n            let value = null;\n            \n            if (this.connected) {\n                value = await this.redis.get(fullKey);\n                \n                if (value !== null) {\n                    this.stats.hits++;\n                    \n                    if (deserialize && typeof value === 'string') {\n                        try {\n                            value = JSON.parse(value);\n                        } catch (parseError) {\n                            logger.warn('Failed to deserialize cached value', {\n                                key: fullKey,\n                                error: parseError\n                            });\n                        }\n                    }\n                    \n                    return value;\n                }\n            }\n            \n            // Try fallback cache\n            if (this.fallbackCache.has(fullKey)) {\n                const cachedItem = this.fallbackCache.get(fullKey);\n                \n                // Check if not expired\n                if (cachedItem.expires > Date.now()) {\n                    this.stats.fallbackHits++;\n                    return cachedItem.value;\n                } else {\n                    this.fallbackCache.delete(fullKey);\n                }\n            }\n            \n            this.stats.misses++;\n            return null;\n            \n        } catch (error) {\n            this.stats.errors++;\n            logger.error('Cache get operation failed', {\n                key: fullKey,\n                error\n            });\n            \n            // Try fallback cache on error\n            if (this.fallbackCache.has(fullKey)) {\n                const cachedItem = this.fallbackCache.get(fullKey);\n                if (cachedItem.expires > Date.now()) {\n                    this.stats.fallbackHits++;\n                    return cachedItem.value;\n                }\n            }\n            \n            return null;\n        }\n    }\n\n    /**\n     * Set value in cache\n     */\n    async set(key, value, options = {}) {\n        const {\n            tier = 'warm',\n            ttl = this.tiers[tier]?.ttl || this.config.defaultTTL,\n            serialize = true\n        } = options;\n        \n        const fullKey = this.buildKey(key, tier);\n        \n        try {\n            let serializedValue = value;\n            \n            if (serialize && typeof value !== 'string') {\n                serializedValue = JSON.stringify(value);\n            }\n            \n            if (this.connected) {\n                await this.redis.setex(fullKey, ttl, serializedValue);\n            }\n            \n            // Also store in fallback cache\n            this.fallbackCache.set(fullKey, {\n                value,\n                expires: Date.now() + (ttl * 1000)\n            });\n            \n            this.stats.sets++;\n            return true;\n            \n        } catch (error) {\n            this.stats.errors++;\n            logger.error('Cache set operation failed', {\n                key: fullKey,\n                error\n            });\n            \n            // Store in fallback cache on Redis error\n            this.fallbackCache.set(fullKey, {\n                value,\n                expires: Date.now() + (ttl * 1000)\n            });\n            \n            return false;\n        }\n    }\n\n    /**\n     * Delete value from cache\n     */\n    async delete(key, options = {}) {\n        const { tier = 'warm' } = options;\n        const fullKey = this.buildKey(key, tier);\n        \n        try {\n            if (this.connected) {\n                await this.redis.del(fullKey);\n            }\n            \n            this.fallbackCache.delete(fullKey);\n            \n            this.stats.deletes++;\n            return true;\n            \n        } catch (error) {\n            this.stats.errors++;\n            logger.error('Cache delete operation failed', {\n                key: fullKey,\n                error\n            });\n            return false;\n        }\n    }\n\n    /**\n     * Get or set value with function\n     */\n    async getOrSet(key, fetchFunction, options = {}) {\n        const value = await this.get(key, options);\n        \n        if (value !== null) {\n            return value;\n        }\n        \n        try {\n            const freshValue = await fetchFunction();\n            \n            if (freshValue !== null && freshValue !== undefined) {\n                await this.set(key, freshValue, options);\n            }\n            \n            return freshValue;\n            \n        } catch (error) {\n            logger.error('Cache fetch function failed', {\n                key: this.buildKey(key, options.tier),\n                error\n            });\n            return null;\n        }\n    }\n\n    /**\n     * Cache AI model results with intelligent invalidation\n     */\n    async cacheModelResult(modelId, inputHash, result, options = {}) {\n        const key = `model:${modelId}:${inputHash}`;\n        const { tier = 'hot' } = options; // Models results are frequently accessed\n        \n        return this.set(key, {\n            result,\n            modelId,\n            cachedAt: Date.now(),\n            inputHash\n        }, { tier, ...options });\n    }\n\n    /**\n     * Get cached AI model result\n     */\n    async getCachedModelResult(modelId, inputHash) {\n        const key = `model:${modelId}:${inputHash}`;\n        const cached = await this.get(key, { tier: 'hot' });\n        \n        if (cached) {\n            return {\n                ...cached,\n                cacheHit: true,\n                age: Date.now() - cached.cachedAt\n            };\n        }\n        \n        return null;\n    }\n\n    /**\n     * Cache user session data\n     */\n    async cacheUserSession(userId, sessionData, options = {}) {\n        const key = `session:${userId}`;\n        const { tier = 'warm', ttl = 1800 } = options; // 30 minutes for sessions\n        \n        return this.set(key, {\n            ...sessionData,\n            userId,\n            lastAccessed: Date.now()\n        }, { tier, ttl });\n    }\n\n    /**\n     * Get cached user session\n     */\n    async getUserSession(userId) {\n        const key = `session:${userId}`;\n        return this.get(key, { tier: 'warm' });\n    }\n\n    /**\n     * Cache API response with auto-expiry\n     */\n    async cacheApiResponse(endpoint, params, response, options = {}) {\n        const key = this.generateApiCacheKey(endpoint, params);\n        const { tier = 'cold', ttl = 300 } = options; // 5 minutes for API responses\n        \n        return this.set(key, {\n            response,\n            endpoint,\n            params,\n            cachedAt: Date.now()\n        }, { tier, ttl });\n    }\n\n    /**\n     * Get cached API response\n     */\n    async getCachedApiResponse(endpoint, params) {\n        const key = this.generateApiCacheKey(endpoint, params);\n        return this.get(key, { tier: 'cold' });\n    }\n\n    /**\n     * Invalidate cache patterns\n     */\n    async invalidatePattern(pattern, options = {}) {\n        const { tier = '*' } = options;\n        \n        try {\n            if (this.connected) {\n                let searchPattern = pattern;\n                \n                if (tier !== '*') {\n                    searchPattern = this.tiers[tier]?.prefix + pattern;\n                }\n                \n                const keys = await this.redis.keys(searchPattern);\n                \n                if (keys.length > 0) {\n                    await this.redis.del(...keys);\n                    logger.debug('Cache pattern invalidated', {\n                        pattern: searchPattern,\n                        keysDeleted: keys.length\n                    });\n                }\n            }\n            \n            // Also clear from fallback cache\n            const fallbackKeys = Array.from(this.fallbackCache.keys());\n            const matchingKeys = fallbackKeys.filter(key => \n                key.includes(pattern) || (tier !== '*' && key.includes(this.tiers[tier]?.prefix))\n            );\n            \n            matchingKeys.forEach(key => this.fallbackCache.delete(key));\n            \n            return true;\n            \n        } catch (error) {\n            this.stats.errors++;\n            logger.error('Cache pattern invalidation failed', {\n                pattern,\n                error\n            });\n            return false;\n        }\n    }\n\n    /**\n     * Warm up cache with predefined data\n     */\n    async warmUp(warmUpData) {\n        const results = [];\n        \n        for (const item of warmUpData) {\n            try {\n                const { key, value, tier = 'warm', ttl } = item;\n                const success = await this.set(key, value, { tier, ttl });\n                results.push({ key, success });\n            } catch (error) {\n                logger.error('Cache warm-up item failed', {\n                    key: item.key,\n                    error\n                });\n                results.push({ key: item.key, success: false, error });\n            }\n        }\n        \n        logger.info('Cache warm-up completed', {\n            total: warmUpData.length,\n            successful: results.filter(r => r.success).length\n        });\n        \n        return results;\n    }\n\n    /**\n     * Build cache key with tier prefix\n     */\n    buildKey(key, tier = 'warm') {\n        const tierConfig = this.tiers[tier];\n        if (!tierConfig) {\n            throw new Error(`Unknown cache tier: ${tier}`);\n        }\n        \n        return `${tierConfig.prefix}${key}`;\n    }\n\n    /**\n     * Generate API cache key from endpoint and params\n     */\n    generateApiCacheKey(endpoint, params = {}) {\n        const sortedParams = Object.keys(params)\n            .sort()\n            .reduce((result, key) => {\n                result[key] = params[key];\n                return result;\n            }, {});\n        \n        const paramString = JSON.stringify(sortedParams);\n        const hash = createHash('sha256')\n            .update(endpoint + paramString)\n            .digest('hex')\n            .substring(0, 16);\n        \n        return `api:${endpoint.replace(/\\//g, ':')}:${hash}`;\n    }\n\n    /**\n     * Get cache statistics\n     */\n    getStatistics() {\n        const hitRate = this.stats.hits + this.stats.misses > 0 ?\n            (this.stats.hits / (this.stats.hits + this.stats.misses) * 100).toFixed(2) :\n            0;\n        \n        return {\n            ...this.stats,\n            hitRate: parseFloat(hitRate),\n            connected: this.connected,\n            fallbackCacheSize: this.fallbackCache.size,\n            uptime: process.uptime()\n        };\n    }\n\n    /**\n     * Health check\n     */\n    async healthCheck() {\n        try {\n            if (this.connected) {\n                await this.redis.ping();\n                return {\n                    status: 'healthy',\n                    connected: true,\n                    lastError: null\n                };\n            } else {\n                return {\n                    status: 'degraded',\n                    connected: false,\n                    fallbackActive: true,\n                    lastError: 'Redis connection lost'\n                };\n            }\n        } catch (error) {\n            return {\n                status: 'unhealthy',\n                connected: false,\n                fallbackActive: true,\n                lastError: error.message\n            };\n        }\n    }\n\n    /**\n     * Start cleanup interval for fallback cache\n     */\n    startCleanupInterval() {\n        setInterval(() => {\n            const now = Date.now();\n            let cleaned = 0;\n            \n            for (const [key, item] of this.fallbackCache.entries()) {\n                if (item.expires <= now) {\n                    this.fallbackCache.delete(key);\n                    cleaned++;\n                }\n            }\n            \n            if (cleaned > 0) {\n                logger.debug('Fallback cache cleanup', {\n                    expiredItems: cleaned,\n                    remainingItems: this.fallbackCache.size\n                });\n            }\n        }, 60000); // Cleanup every minute\n    }\n\n    /**\n     * Shutdown cache manager\n     */\n    async shutdown() {\n        try {\n            if (this.redis) {\n                await this.redis.quit();\n            }\n            \n            this.fallbackCache.clear();\n            this.connected = false;\n            \n            logger.info('Cache manager shutdown completed');\n        } catch (error) {\n            logger.error('Cache manager shutdown error', { error });\n        }\n    }\n}\n\n// Export singleton instance\nlet cacheManager = null;\n\nfunction createCacheManager(options) {\n    if (!cacheManager) {\n        cacheManager = new CacheManager(options);\n    }\n    return cacheManager;\n}\n\nfunction getCacheManager() {\n    if (!cacheManager) {\n        cacheManager = new CacheManager();\n    }\n    return cacheManager;\n}\n\nmodule.exports = {\n    CacheManager,\n    createCacheManager,\n    getCacheManager\n};