/**\n * Monitoring Dashboard API and Metrics Collection\n * Provides comprehensive system monitoring with Prometheus metrics\n */\n\nconst express = require('express'); \nconst { register, Counter, Histogram, Gauge } = require('prom-client'); \nconst os = require('os'); \nconst fs = require('fs').promises; \nconst path = require('path'); \nconst logger = require('../utils/logger'); \nconst { getWebSocketManager } = require('../websocket/taskUpdates'); \nconst { getRateLimiter } = require('../middleware/advancedRateLimiter'); \n\nclass MonitoringDashboard { \n    constructor(options = {}) { \n        this.config = { \n            collectInterval: options.collectInterval || 10000, // 10 seconds\n            historyLength: options.historyLength || 100, // Keep 100 data points\n            enablePrometheus: options.enablePrometheus !== false,\n            ...options\n        };\n\n        // Prometheus metrics\n        this.metrics = {\n            // Counters\n            httpRequestsTotal: new Counter({\n                name: 'http_requests_total',\n                help: 'Total number of HTTP requests',\n                labelNames: ['method', 'endpoint', 'status']\n            }),\n\n            tasksTotal: new Counter({\n                name: 'ai_tasks_total',\n                help: 'Total number of AI tasks processed',\n                labelNames: ['status', 'model_type']\n            }),\n\n            websocketConnectionsTotal: new Counter({\n                name: 'websocket_connections_total',\n                help: 'Total WebSocket connections'\n            }),\n\n            rateLimitHits: new Counter({\n                name: 'rate_limit_hits_total',\n                help: 'Total rate limit hits',\n                labelNames: ['tier', 'endpoint']\n            }),\n\n            // Histograms\n            httpRequestDuration: new Histogram({\n                name: 'http_request_duration_seconds',\n                help: 'HTTP request duration in seconds',\n                labelNames: ['method', 'endpoint'],\n                buckets: [0.1, 0.5, 1, 2, 5, 10, 30]\n            }),\n\n            taskProcessingTime: new Histogram({\n                name: 'ai_task_processing_duration_seconds',\n                help: 'AI task processing duration in seconds',\n                labelNames: ['model_type'],\n                buckets: [1, 5, 10, 30, 60, 120, 300]\n            }),\n\n            // Gauges\n            activeTasks: new Gauge({\n                name: 'ai_tasks_active',\n                help: 'Number of active AI tasks'\n            }),\n\n            activeWebsocketConnections: new Gauge({\n                name: 'websocket_connections_active',\n                help: 'Number of active WebSocket connections'\n            }),\n\n            systemMemoryUsage: new Gauge({\n                name: 'system_memory_usage_bytes',\n                help: 'System memory usage in bytes',\n                labelNames: ['type']\n            }),\n\n            systemCpuUsage: new Gauge({\n                name: 'system_cpu_usage_percent',\n                help: 'System CPU usage percentage'\n            }),\n\n            nodeHealthScore: new Gauge({\n                name: 'node_health_score',\n                help: 'Node health score (0-100)',\n                labelNames: ['node_id']\n            })\n        };\n\n        // Historical data storage\n        this.history = {\n            systemStats: [],\n            taskStats: [],\n            apiStats: [],\n            errorRates: []\n        };\n\n        this.router = express.Router();\n        this.setupRoutes();\n        this.startCollection();\n    }\n\n    /**\n     * Setup monitoring API routes\n     */\n    setupRoutes() {\n        // Prometheus metrics endpoint\n        this.router.get('/metrics', async (req, res) => {\n            try {\n                res.set('Content-Type', register.contentType);\n                const metrics = await register.metrics();\n                res.send(metrics);\n            } catch (error) {\n                logger.error('Failed to export Prometheus metrics', { error });\n                res.status(500).json({ error: 'Failed to export metrics' });\n            }\n        });\n\n        // Dashboard data endpoint\n        this.router.get('/dashboard', (req, res) => {\n            try {\n                const dashboardData = this.getDashboardData();\n                res.json(dashboardData);\n            } catch (error) {\n                logger.error('Failed to get dashboard data', { error });\n                res.status(500).json({ error: 'Failed to get dashboard data' });\n            }\n        });\n\n        // Health check endpoint\n        this.router.get('/health', (req, res) => {\n            const health = this.getHealthStatus();\n            const statusCode = health.status === 'healthy' ? 200 : 503;\n            res.status(statusCode).json(health);\n        });\n\n        // System stats endpoint\n        this.router.get('/stats/system', (req, res) => {\n            try {\n                const systemStats = this.getSystemStats();\n                res.json(systemStats);\n            } catch (error) {\n                logger.error('Failed to get system stats', { error });\n                res.status(500).json({ error: 'Failed to get system stats' });\n            }\n        });\n\n        // API performance stats\n        this.router.get('/stats/api', (req, res) => {\n            try {\n                const apiStats = this.getAPIStats();\n                res.json(apiStats);\n            } catch (error) {\n                logger.error('Failed to get API stats', { error });\n                res.status(500).json({ error: 'Failed to get API stats' });\n            }\n        });\n\n        // Task processing stats\n        this.router.get('/stats/tasks', (req, res) => {\n            try {\n                const taskStats = this.getTaskStats();\n                res.json(taskStats);\n            } catch (error) {\n                logger.error('Failed to get task stats', { error });\n                res.status(500).json({ error: 'Failed to get task stats' });\n            }\n        });\n\n        // WebSocket connection stats\n        this.router.get('/stats/websocket', (req, res) => {\n            try {\n                const wsManager = getWebSocketManager();\n                const wsStats = wsManager.getStatistics();\n                res.json(wsStats);\n            } catch (error) {\n                logger.error('Failed to get WebSocket stats', { error });\n                res.status(500).json({ error: 'Failed to get WebSocket stats' });\n            }\n        });\n\n        // Rate limiting stats\n        this.router.get('/stats/rate-limits', async (req, res) => {\n            try {\n                const rateLimiter = getRateLimiter();\n                const rateLimitStats = await rateLimiter.getStatistics();\n                res.json(rateLimitStats);\n            } catch (error) {\n                logger.error('Failed to get rate limit stats', { error });\n                res.status(500).json({ error: 'Failed to get rate limit stats' });\n            }\n        });\n\n        // Historical trends\n        this.router.get('/trends/:metric', (req, res) => {\n            try {\n                const { metric } = req.params;\n                const { timeRange = '1h' } = req.query;\n                \n                const trends = this.getTrends(metric, timeRange);\n                res.json(trends);\n            } catch (error) {\n                logger.error('Failed to get trends', { error, metric: req.params.metric });\n                res.status(500).json({ error: 'Failed to get trends' });\n            }\n        });\n\n        // Node performance comparison\n        this.router.get('/nodes', (req, res) => {\n            try {\n                const nodeStats = this.getNodeStats();\n                res.json(nodeStats);\n            } catch (error) {\n                logger.error('Failed to get node stats', { error });\n                res.status(500).json({ error: 'Failed to get node stats' });\n            }\n        });\n\n        logger.info('Monitoring dashboard routes initialized');\n    }\n\n    /**\n     * Record HTTP request metrics\n     */\n    recordHttpRequest(method, endpoint, status, duration) {\n        this.metrics.httpRequestsTotal\n            .labels(method, endpoint, status.toString())\n            .inc();\n\n        this.metrics.httpRequestDuration\n            .labels(method, endpoint)\n            .observe(duration / 1000); // Convert to seconds\n    }\n\n    /**\n     * Record AI task metrics\n     */\n    recordTaskMetrics(status, modelType, processingTime) {\n        this.metrics.tasksTotal\n            .labels(status, modelType || 'unknown')\n            .inc();\n\n        if (processingTime) {\n            this.metrics.taskProcessingTime\n                .labels(modelType || 'unknown')\n                .observe(processingTime / 1000);\n        }\n    }\n\n    /**\n     * Record WebSocket connection\n     */\n    recordWebSocketConnection() {\n        this.metrics.websocketConnectionsTotal.inc();\n    }\n\n    /**\n     * Record rate limit hit\n     */\n    recordRateLimitHit(tier, endpoint) {\n        this.metrics.rateLimitHits\n            .labels(tier, endpoint)\n            .inc();\n    }\n\n    /**\n     * Update active task count\n     */\n    updateActiveTasks(count) {\n        this.metrics.activeTasks.set(count);\n    }\n\n    /**\n     * Update active WebSocket connections\n     */\n    updateActiveWebSocketConnections(count) {\n        this.metrics.activeWebsocketConnections.set(count);\n    }\n\n    /**\n     * Collect system metrics\n     */\n    collectSystemMetrics() {\n        try {\n            // Memory usage\n            const memoryUsage = process.memoryUsage();\n            this.metrics.systemMemoryUsage.labels('rss').set(memoryUsage.rss);\n            this.metrics.systemMemoryUsage.labels('heapUsed').set(memoryUsage.heapUsed);\n            this.metrics.systemMemoryUsage.labels('heapTotal').set(memoryUsage.heapTotal);\n            this.metrics.systemMemoryUsage.labels('external').set(memoryUsage.external);\n\n            // CPU usage (simple approximation)\n            const cpus = os.cpus();\n            let totalIdle = 0;\n            let totalTick = 0;\n\n            cpus.forEach(cpu => {\n                for (type in cpu.times) {\n                    totalTick += cpu.times[type];\n                }\n                totalIdle += cpu.times.idle;\n            });\n\n            const idle = totalIdle / cpus.length;\n            const total = totalTick / cpus.length;\n            const cpuUsage = 100 - ~~(100 * idle / total);\n            \n            this.metrics.systemCpuUsage.set(cpuUsage);\n\n            // Add to history\n            const systemStats = {\n                timestamp: Date.now(),\n                memory: {\n                    rss: memoryUsage.rss,\n                    heapUsed: memoryUsage.heapUsed,\n                    heapTotal: memoryUsage.heapTotal\n                },\n                cpu: cpuUsage,\n                uptime: process.uptime(),\n                loadAverage: os.loadavg()\n            };\n\n            this.addToHistory('systemStats', systemStats);\n\n        } catch (error) {\n            logger.error('Failed to collect system metrics', { error });\n        }\n    }\n\n    /**\n     * Get comprehensive dashboard data\n     */\n    getDashboardData() {\n        const wsManager = getWebSocketManager();\n        const wsStats = wsManager.getStatistics();\n        \n        return {\n            timestamp: Date.now(),\n            system: this.getSystemStats(),\n            websocket: wsStats,\n            api: this.getAPIStats(),\n            tasks: this.getTaskStats(),\n            health: this.getHealthStatus(),\n            uptime: process.uptime()\n        };\n    }\n\n    /**\n     * Get current system statistics\n     */\n    getSystemStats() {\n        return {\n            memory: {\n                total: os.totalmem(),\n                free: os.freemem(),\n                used: os.totalmem() - os.freemem(),\n                process: process.memoryUsage()\n            },\n            cpu: {\n                count: os.cpus().length,\n                model: os.cpus()[0]?.model,\n                loadAverage: os.loadavg()\n            },\n            platform: os.platform(),\n            arch: os.arch(),\n            nodeVersion: process.version,\n            uptime: {\n                system: os.uptime(),\n                process: process.uptime()\n            }\n        };\n    }\n\n    /**\n     * Get API performance statistics\n     */\n    getAPIStats() {\n        // Get recent history for API stats\n        const recentStats = this.history.apiStats.slice(-10);\n        \n        const totalRequests = recentStats.reduce((sum, stat) => sum + (stat.requests || 0), 0);\n        const averageResponseTime = recentStats.length > 0 ?\n            recentStats.reduce((sum, stat) => sum + (stat.averageResponseTime || 0), 0) / recentStats.length :\n            0;\n\n        return {\n            totalRequests,\n            averageResponseTime,\n            recentHistory: recentStats,\n            endpoints: this.getEndpointStats()\n        };\n    }\n\n    /**\n     * Get task processing statistics\n     */\n    getTaskStats() {\n        const recentStats = this.history.taskStats.slice(-10);\n        \n        return {\n            totalProcessed: recentStats.reduce((sum, stat) => sum + (stat.completed || 0), 0),\n            activeCount: recentStats.length > 0 ? recentStats[recentStats.length - 1].active || 0 : 0,\n            averageProcessingTime: recentStats.length > 0 ?\n                recentStats.reduce((sum, stat) => sum + (stat.averageTime || 0), 0) / recentStats.length :\n                0,\n            recentHistory: recentStats\n        };\n    }\n\n    /**\n     * Get health status\n     */\n    getHealthStatus() {\n        const memoryUsage = process.memoryUsage();\n        const memoryUsagePercent = (memoryUsage.heapUsed / memoryUsage.heapTotal) * 100;\n        const uptime = process.uptime();\n        \n        let status = 'healthy';\n        const issues = [];\n        \n        // Check memory usage\n        if (memoryUsagePercent > 90) {\n            status = 'unhealthy';\n            issues.push('High memory usage');\n        } else if (memoryUsagePercent > 75) {\n            status = 'warning';\n            issues.push('Elevated memory usage');\n        }\n        \n        // Check if recently started (potential restart)\n        if (uptime < 300) { // 5 minutes\n            status = 'warning';\n            issues.push('Recently restarted');\n        }\n        \n        return {\n            status,\n            uptime,\n            memoryUsagePercent: Math.round(memoryUsagePercent),\n            issues,\n            lastCheck: Date.now()\n        };\n    }\n\n    /**\n     * Get endpoint-specific statistics\n     */\n    getEndpointStats() {\n        // Mock endpoint stats - in production, this would come from middleware\n        return {\n            '/api/v1/tasks': {\n                requests: 150,\n                averageResponseTime: 245,\n                errorRate: 2.1\n            },\n            '/api/v1/models': {\n                requests: 89,\n                averageResponseTime: 156,\n                errorRate: 0.8\n            },\n            '/api/v1/auth': {\n                requests: 45,\n                averageResponseTime: 89,\n                errorRate: 1.2\n            }\n        };\n    }\n\n    /**\n     * Get trends for specific metric\n     */\n    getTrends(metric, timeRange) {\n        let historicalData = [];\n        \n        switch (metric) {\n            case 'system':\n                historicalData = this.history.systemStats;\n                break;\n            case 'tasks':\n                historicalData = this.history.taskStats;\n                break;\n            case 'api':\n                historicalData = this.history.apiStats;\n                break;\n            default:\n                throw new Error(`Unknown metric: ${metric}`);\n        }\n        \n        // Filter by time range\n        const now = Date.now();\n        const timeRangeMs = this.parseTimeRange(timeRange);\n        \n        const filteredData = historicalData.filter(data => \n            now - data.timestamp <= timeRangeMs\n        );\n        \n        return {\n            metric,\n            timeRange,\n            dataPoints: filteredData.length,\n            data: filteredData\n        };\n    }\n\n    /**\n     * Parse time range string to milliseconds\n     */\n    parseTimeRange(timeRange) {\n        const multipliers = {\n            'm': 60 * 1000,\n            'h': 60 * 60 * 1000,\n            'd': 24 * 60 * 60 * 1000\n        };\n        \n        const match = timeRange.match(/(\\d+)([mhd])/);\n        if (!match) return 60 * 60 * 1000; // Default 1 hour\n        \n        const [, amount, unit] = match;\n        return parseInt(amount) * multipliers[unit];\n    }\n\n    /**\n     * Get node performance statistics\n     */\n    getNodeStats() {\n        // Mock node stats - in production, this would come from node registry\n        return {\n            totalNodes: 5,\n            activeNodes: 4,\n            nodes: [\n                {\n                    id: 'node-001',\n                    status: 'active',\n                    healthScore: 98,\n                    tasksCompleted: 245,\n                    averageResponseTime: 1.2,\n                    lastSeen: Date.now() - 30000\n                },\n                {\n                    id: 'node-002', \n                    status: 'active',\n                    healthScore: 95,\n                    tasksCompleted: 189,\n                    averageResponseTime: 1.8,\n                    lastSeen: Date.now() - 15000\n                },\n                {\n                    id: 'node-003',\n                    status: 'inactive',\n                    healthScore: 0,\n                    tasksCompleted: 156,\n                    averageResponseTime: 2.1,\n                    lastSeen: Date.now() - 300000\n                }\n            ]\n        };\n    }\n\n    /**\n     * Add data to historical storage\n     */\n    addToHistory(category, data) {\n        if (!this.history[category]) {\n            this.history[category] = [];\n        }\n        \n        this.history[category].push(data);\n        \n        // Keep only recent data\n        if (this.history[category].length > this.config.historyLength) {\n            this.history[category] = this.history[category].slice(-this.config.historyLength);\n        }\n    }\n\n    /**\n     * Start metrics collection\n     */\n    startCollection() {\n        // Collect system metrics periodically\n        setInterval(() => {\n            this.collectSystemMetrics();\n        }, this.config.collectInterval);\n        \n        // Update WebSocket connection count\n        setInterval(() => {\n            try {\n                const wsManager = getWebSocketManager();\n                const wsStats = wsManager.getStatistics();\n                this.updateActiveWebSocketConnections(wsStats.activeConnections);\n            } catch (error) {\n                // WebSocket manager not initialized yet\n            }\n        }, 5000);\n        \n        logger.info('Monitoring dashboard metrics collection started', {\n            collectInterval: this.config.collectInterval,\n            historyLength: this.config.historyLength\n        });\n    }\n\n    /**\n     * Get Express router for monitoring endpoints\n     */\n    getRouter() {\n        return this.router;\n    }\n\n    /**\n     * Shutdown monitoring dashboard\n     */\n    shutdown() {\n        logger.info('Shutting down monitoring dashboard');\n        // Clear any intervals if stored\n    }\n}\n\n// Export singleton instance\nlet monitoringDashboard = null;\n\nfunction createMonitoringDashboard(options) {\n    if (!monitoringDashboard) {\n        monitoringDashboard = new MonitoringDashboard(options);\n    }\n    return monitoringDashboard;\n}\n\nfunction getMonitoringDashboard() {\n    if (!monitoringDashboard) {\n        monitoringDashboard = new MonitoringDashboard();\n    }\n    return monitoringDashboard;\n}\n\nmodule.exports = {\n    MonitoringDashboard,\n    createMonitoringDashboard,\n    getMonitoringDashboard\n};