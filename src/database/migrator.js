/**\n * Database Migration System for NeuroGrid\n * Handles versioned database schema changes with rollback support\n */\n\nconst fs = require('fs').promises; \nconst path = require('path'); \nconst { Pool } = require('pg'); \nconst logger = require('../utils/logger'); \n\nclass DatabaseMigrator { \n    constructor(options = {}) { \n        this.config = { \n            migrationsDir: options.migrationsDir || path.join(process.cwd(), 'migrations'), \n            migrationsTable: options.migrationsTable || 'schema_migrations', \n            connectionConfig: options.connectionConfig || { \n                host: process.env.POSTGRES_HOST || 'localhost', \n                port: process.env.POSTGRES_PORT || 5432, \n                database: process.env.POSTGRES_DB || 'neurogrid', \n                user: process.env.POSTGRES_USER || 'neurogrid', \n                password: process.env.POSTGRES_PASSWORD || 'neurogrid123', \n                ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false\n }, \n            lockTable: options.lockTable || 'migration_lock', \n            ...options\n }; \n\n        this.pool = new Pool(this.config.connectionConfig); \n        this.migrationPattern = /^(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})_(.+)\\.(js|sql)$/; \n } \n\n    /**\n     * Initialize migration system\n     */\n    async initialize() { \n        try { \n            // Test database connection\n            const client = await this.pool.connect();\n            \n            // Create migrations table if it doesn't exist\n            await client.query(`\n                CREATE TABLE IF NOT EXISTS ${this.config.migrationsTable} (\n                    id SERIAL PRIMARY KEY,\n                    version VARCHAR(255) NOT NULL UNIQUE,\n                    filename VARCHAR(255) NOT NULL,\n                    checksum VARCHAR(64) NOT NULL,\n                    applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    execution_time INTEGER NOT NULL,\n                    success BOOLEAN NOT NULL DEFAULT TRUE\n                )\n            `);\n\n            // Create migration lock table\n            await client.query(`\n                CREATE TABLE IF NOT EXISTS ${this.config.lockTable} (\n                    id INTEGER PRIMARY KEY DEFAULT 1,\n                    locked BOOLEAN DEFAULT FALSE,\n                    locked_at TIMESTAMP,\n                    locked_by VARCHAR(255),\n                    CONSTRAINT single_row CHECK (id = 1)\n                )\n            `);\n\n            // Insert lock row if it doesn't exist\n            await client.query(`\n                INSERT INTO ${this.config.lockTable} (id, locked)\n                VALUES (1, FALSE)\n                ON CONFLICT (id) DO NOTHING\n            `);\n\n            client.release();\n\n            // Ensure migrations directory exists\n            try {\n                await fs.access(this.config.migrationsDir);\n            } catch (error) {\n                await fs.mkdir(this.config.migrationsDir, { recursive: true });\n                logger.info('Created migrations directory', {\n                    directory: this.config.migrationsDir\n                });\n            }\n\n            logger.info('Database migration system initialized', {\n                migrationsDir: this.config.migrationsDir,\n                migrationsTable: this.config.migrationsTable\n            });\n\n        } catch (error) {\n            logger.error('Failed to initialize migration system', { error });\n            throw error;\n        }\n    }\n\n    /**\n     * Run pending migrations\n     */\n    async migrate() {\n        const lockId = `migrate-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n        \n        try {\n            // Acquire migration lock\n            await this.acquireLock(lockId);\n            \n            const pendingMigrations = await this.getPendingMigrations();\n            \n            if (pendingMigrations.length === 0) {\n                logger.info('No pending migrations found');\n                return {\n                    success: true,\n                    appliedMigrations: [],\n                    message: 'No pending migrations'\n                };\n            }\n\n            logger.info('Starting migration process', {\n                pendingCount: pendingMigrations.length,\n                migrations: pendingMigrations.map(m => m.filename)\n            });\n\n            const appliedMigrations = [];\n            const client = await this.pool.connect();\n\n            try {\n                // Run migrations in transaction\n                await client.query('BEGIN');\n\n                for (const migration of pendingMigrations) {\n                    const startTime = Date.now();\n                    \n                    logger.info('Applying migration', {\n                        filename: migration.filename,\n                        version: migration.version\n                    });\n\n                    try {\n                        if (migration.type === 'sql') {\n                            await client.query(migration.sql);\n                        } else if (migration.type === 'js') {\n                            await migration.up(client);\n                        }\n\n                        const executionTime = Date.now() - startTime;\n\n                        // Record successful migration\n                        await client.query(`\n                            INSERT INTO ${this.config.migrationsTable}\n                            (version, filename, checksum, execution_time, success)\n                            VALUES ($1, $2, $3, $4, $5)\n                        `, [\n                            migration.version,\n                            migration.filename,\n                            migration.checksum,\n                            executionTime,\n                            true\n                        ]);\n\n                        appliedMigrations.push({\n                            ...migration,\n                            executionTime\n                        });\n\n                        logger.info('Migration applied successfully', {\n                            filename: migration.filename,\n                            executionTime\n                        });\n\n                    } catch (migrationError) {\n                        logger.error('Migration failed', {\n                            filename: migration.filename,\n                            error: migrationError\n                        });\n\n                        // Record failed migration\n                        await client.query(`\n                            INSERT INTO ${this.config.migrationsTable}\n                            (version, filename, checksum, execution_time, success)\n                            VALUES ($1, $2, $3, $4, $5)\n                        `, [\n                            migration.version,\n                            migration.filename,\n                            migration.checksum,\n                            Date.now() - startTime,\n                            false\n                        ]);\n\n                        throw migrationError;\n                    }\n                }\n\n                await client.query('COMMIT');\n                \n                logger.info('All migrations applied successfully', {\n                    count: appliedMigrations.length\n                });\n\n                return {\n                    success: true,\n                    appliedMigrations,\n                    message: `Applied ${appliedMigrations.length} migrations`\n                };\n\n            } catch (error) {\n                await client.query('ROLLBACK');\n                throw error;\n            } finally {\n                client.release();\n            }\n\n        } catch (error) {\n            logger.error('Migration process failed', { error });\n            throw error;\n        } finally {\n            await this.releaseLock(lockId);\n        }\n    }\n\n    /**\n     * Rollback migrations\n     */\n    async rollback(options = {}) {\n        const lockId = `rollback-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n        const { steps = 1, toVersion = null } = options;\n        \n        try {\n            await this.acquireLock(lockId);\n            \n            const client = await this.pool.connect();\n            \n            try {\n                let migrationsToRollback;\n                \n                if (toVersion) {\n                    // Rollback to specific version\n                    const result = await client.query(`\n                        SELECT version, filename FROM ${this.config.migrationsTable}\n                        WHERE success = TRUE AND version > $1\n                        ORDER BY version DESC\n                    `, [toVersion]);\n                    \n                    migrationsToRollback = result.rows;\n                } else {\n                    // Rollback last N migrations\n                    const result = await client.query(`\n                        SELECT version, filename FROM ${this.config.migrationsTable}\n                        WHERE success = TRUE\n                        ORDER BY version DESC\n                        LIMIT $1\n                    `, [steps]);\n                    \n                    migrationsToRollback = result.rows;\n                }\n                \n                if (migrationsToRollback.length === 0) {\n                    logger.info('No migrations to rollback');\n                    return {\n                        success: true,\n                        rolledBackMigrations: [],\n                        message: 'No migrations to rollback'\n                    };\n                }\n                \n                logger.info('Starting rollback process', {\n                    migrationsCount: migrationsToRollback.length,\n                    migrations: migrationsToRollback.map(m => m.filename)\n                });\n                \n                const rolledBackMigrations = [];\n                \n                await client.query('BEGIN');\n                \n                for (const migrationRecord of migrationsToRollback) {\n                    const migration = await this.loadMigration(\n                        path.join(this.config.migrationsDir, migrationRecord.filename)\n                    );\n                    \n                    logger.info('Rolling back migration', {\n                        filename: migration.filename,\n                        version: migration.version\n                    });\n                    \n                    try {\n                        if (migration.type === 'js' && migration.down) {\n                            await migration.down(client);\n                        } else {\n                            logger.warn('No rollback available for migration', {\n                                filename: migration.filename\n                            });\n                        }\n                        \n                        // Remove migration record\n                        await client.query(`\n                            DELETE FROM ${this.config.migrationsTable}\n                            WHERE version = $1\n                        `, [migration.version]);\n                        \n                        rolledBackMigrations.push(migration);\n                        \n                    } catch (rollbackError) {\n                        logger.error('Rollback failed', {\n                            filename: migration.filename,\n                            error: rollbackError\n                        });\n                        throw rollbackError;\n                    }\n                }\n                \n                await client.query('COMMIT');\n                \n                logger.info('Rollback completed successfully', {\n                    count: rolledBackMigrations.length\n                });\n                \n                return {\n                    success: true,\n                    rolledBackMigrations,\n                    message: `Rolled back ${rolledBackMigrations.length} migrations`\n                };\n                \n            } catch (error) {\n                await client.query('ROLLBACK');\n                throw error;\n            } finally {\n                client.release();\n            }\n            \n        } catch (error) {\n            logger.error('Rollback process failed', { error });\n            throw error;\n        } finally {\n            await this.releaseLock(lockId);\n        }\n    }\n\n    /**\n     * Get migration status\n     */\n    async getStatus() {\n        try {\n            const client = await this.pool.connect();\n            \n            // Get applied migrations\n            const appliedResult = await client.query(`\n                SELECT version, filename, applied_at, execution_time, success\n                FROM ${this.config.migrationsTable}\n                ORDER BY version ASC\n            `);\n            \n            client.release();\n            \n            // Get all migration files\n            const allMigrations = await this.getAllMigrations();\n            const pendingMigrations = await this.getPendingMigrations();\n            \n            return {\n                applied: appliedResult.rows,\n                pending: pendingMigrations,\n                total: allMigrations.length,\n                appliedCount: appliedResult.rows.filter(m => m.success).length,\n                pendingCount: pendingMigrations.length,\n                failedCount: appliedResult.rows.filter(m => !m.success).length\n            };\n            \n        } catch (error) {\n            logger.error('Failed to get migration status', { error });\n            throw error;\n        }\n    }\n\n    /**\n     * Create new migration file\n     */\n    async createMigration(name, type = 'sql') {\n        const timestamp = new Date().toISOString()\n            .replace(/[-T:]/g, '')\n            .replace(/\\.\\d{3}Z$/, '');\n        \n        const filename = `${timestamp}_${name.replace(/\\s+/g, '_').toLowerCase()}.${type}`;\n        const filePath = path.join(this.config.migrationsDir, filename);\n        \n        let content;\n        \n        if (type === 'sql') {\n            content = `-- Migration: ${name}\n-- Created: ${new Date().toISOString()}\n\n-- Add your SQL migration here\n-- Example:\n-- CREATE TABLE example (\n--     id SERIAL PRIMARY KEY,\n--     name VARCHAR(255) NOT NULL\n-- );\n`;\n        } else if (type === 'js') {\n            content = `/**\n * Migration: ${name}\n * Created: ${new Date().toISOString()}\n */\n\nmodule.exports = {\n    async up(client) {\n        // Add your migration logic here\n        // Example:\n        // await client.query('CREATE TABLE example (id SERIAL PRIMARY KEY)');\n    },\n\n    async down(client) {\n        // Add your rollback logic here\n        // Example:\n        // await client.query('DROP TABLE IF EXISTS example');\n    }\n};\n`;\n        }\n        \n        await fs.writeFile(filePath, content, 'utf8');\n        \n        logger.info('Migration file created', {\n            filename,\n            path: filePath,\n            type\n        });\n        \n        return {\n            filename,\n            path: filePath,\n            type\n        };\n    }\n\n    /**\n     * Get all pending migrations\n     */\n    async getPendingMigrations() {\n        try {\n            const client = await this.pool.connect();\n            \n            // Get applied migrations\n            const appliedResult = await client.query(`\n                SELECT version FROM ${this.config.migrationsTable}\n                WHERE success = TRUE\n            `);\n            \n            client.release();\n            \n            const appliedVersions = new Set(appliedResult.rows.map(row => row.version));\n            \n            // Get all migration files\n            const allMigrations = await this.getAllMigrations();\n            \n            // Filter out applied migrations\n            const pendingMigrations = allMigrations.filter(migration => \n                !appliedVersions.has(migration.version)\n            );\n            \n            return pendingMigrations;\n            \n        } catch (error) {\n            logger.error('Failed to get pending migrations', { error });\n            throw error;\n        }\n    }\n\n    /**\n     * Get all migration files\n     */\n    async getAllMigrations() {\n        try {\n            const files = await fs.readdir(this.config.migrationsDir);\n            const migrations = [];\n            \n            for (const filename of files) {\n                const match = filename.match(this.migrationPattern);\n                if (!match) continue;\n                \n                const filePath = path.join(this.config.migrationsDir, filename);\n                const migration = await this.loadMigration(filePath);\n                migrations.push(migration);\n            }\n            \n            // Sort by version\n            migrations.sort((a, b) => a.version.localeCompare(b.version));\n            \n            return migrations;\n            \n        } catch (error) {\n            logger.error('Failed to get all migrations', { error });\n            throw error;\n        }\n    }\n\n    /**\n     * Load migration file\n     */\n    async loadMigration(filePath) {\n        const filename = path.basename(filePath);\n        const match = filename.match(this.migrationPattern);\n        \n        if (!match) {\n            throw new Error(`Invalid migration filename: ${filename}`);\n        }\n        \n        const [, year, month, day, hour, minute, second, name, ext] = match;\n        const version = `${year}${month}${day}${hour}${minute}${second}`;\n        const type = ext;\n        \n        let migration = {\n            filename,\n            version,\n            name,\n            type,\n            checksum: await this.calculateChecksum(filePath)\n        };\n        \n        if (type === 'sql') {\n            const sql = await fs.readFile(filePath, 'utf8');\n            migration.sql = sql;\n        } else if (type === 'js') {\n            // Clear require cache\n            delete require.cache[require.resolve(filePath)];\n            const migrationModule = require(filePath);\n            migration.up = migrationModule.up;\n            migration.down = migrationModule.down;\n        }\n        \n        return migration;\n    }\n\n    /**\n     * Calculate file checksum\n     */\n    async calculateChecksum(filePath) {\n        const crypto = require('crypto');\n        const content = await fs.readFile(filePath, 'utf8');\n        return crypto.createHash('sha256').update(content).digest('hex');\n    }\n\n    /**\n     * Acquire migration lock\n     */\n    async acquireLock(lockId) {\n        const client = await this.pool.connect();\n        \n        try {\n            const result = await client.query(`\n                UPDATE ${this.config.lockTable}\n                SET locked = TRUE, locked_at = CURRENT_TIMESTAMP, locked_by = $1\n                WHERE id = 1 AND locked = FALSE\n                RETURNING locked\n            `, [lockId]);\n            \n            if (result.rows.length === 0) {\n                throw new Error('Migration lock is already held by another process');\n            }\n            \n            logger.debug('Migration lock acquired', { lockId });\n            \n        } finally {\n            client.release();\n        }\n    }\n\n    /**\n     * Release migration lock\n     */\n    async releaseLock(lockId) {\n        const client = await this.pool.connect();\n        \n        try {\n            await client.query(`\n                UPDATE ${this.config.lockTable}\n                SET locked = FALSE, locked_at = NULL, locked_by = NULL\n                WHERE id = 1 AND locked_by = $1\n            `, [lockId]);\n            \n            logger.debug('Migration lock released', { lockId });\n            \n        } finally {\n            client.release();\n        }\n    }\n\n    /**\n     * Close database connection pool\n     */\n    async shutdown() {\n        await this.pool.end();\n        logger.info('Database migration system shutdown');\n    }\n}\n\nmodule.exports = {\n    DatabaseMigrator\n};