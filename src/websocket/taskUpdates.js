/**
 * Real-time WebSocket Manager for Task Updates
 * Provides live updates for AI task progress and system events
 */

const WebSocket = require('ws'); 
const jwt = require('jsonwebtoken'); 
const EventEmitter = require('events'); 
const logger = require('../utils/logger'); 
const { getRateLimiter } = require('./advancedRateLimiter'); \n\nclass RealtimeWebSocketManager extends EventEmitter { \n    constructor(options = {}) { \n        super(); \n        \n        this.wss = null; \n        this.server = null; \n        this.clients = new Map(); // connectionId -> client info\n        this.rooms = new Map();   // roomId -> Set of connectionIds\n        this.userConnections = new Map(); // userId -> Set of connectionIds\n        \n        this.config = {\n            port: options.port || 3001,\n            path: options.path || '/ws',\n            maxConnections: options.maxConnections || 1000,\n            pingInterval: options.pingInterval || 30000,\n            pongTimeout: options.pongTimeout || 5000,\n            jwtSecret: options.jwtSecret || process.env.JWT_SECRET,\n            ...options\n        };\n        \n        this.stats = {\n            totalConnections: 0,\n            activeConnections: 0,\n            totalMessages: 0,\n            roomsCount: 0\n        };\n        \n        this.rateLimiter = getRateLimiter();\n        this.setupHeartbeat();\n    }\n\n    /**\n     * Initialize WebSocket server\n     */\n    initialize(httpServer) {\n        this.server = httpServer;\n        \n        this.wss = new WebSocket.Server({\n            server: httpServer,\n            path: this.config.path,\n            maxPayload: 1024 * 16 // 16KB max message size\n        });\n\n        this.wss.on('connection', (ws, request) => {\n            this.handleConnection(ws, request);\n        });\n\n        this.wss.on('error', (error) => {\n            logger.error('WebSocket server error', { error });\n        });\n\n        logger.info('WebSocket server initialized', {\n            path: this.config.path,\n            maxConnections: this.config.maxConnections\n        });\n\n        // Cleanup interval\n        setInterval(() => this.cleanup(), 60000);\n    }\n\n    /**\n     * Handle new WebSocket connection\n     */\n    async handleConnection(ws, request) {\n        const connectionId = this.generateConnectionId();\n        const clientIP = request.headers['x-forwarded-for'] || \n                        request.connection.remoteAddress || \n                        request.socket.remoteAddress;\n\n        // Check connection limits\n        if (this.stats.activeConnections >= this.config.maxConnections) {\n            logger.warn('WebSocket connection rejected: max connections reached', {\n                activeConnections: this.stats.activeConnections,\n                maxConnections: this.config.maxConnections,\n                clientIP\n            });\n            \n            ws.close(1013, 'Server overloaded');\n            return;\n        }\n\n        // Initialize client info\n        const clientInfo = {\n            id: connectionId,\n            ws,\n            ip: clientIP,\n            authenticated: false,\n            userId: null,\n            subscriptions: new Set(),\n            rooms: new Set(),\n            connectedAt: Date.now(),\n            lastPing: Date.now(),\n            lastPong: Date.now()\n        };\n\n        this.clients.set(connectionId, clientInfo);\n        this.stats.totalConnections++;\n        this.stats.activeConnections++;\n\n        logger.info('New WebSocket connection', {\n            connectionId,\n            clientIP,\n            totalConnections: this.stats.totalConnections,\n            activeConnections: this.stats.activeConnections\n        });\n\n        // Setup connection handlers\n        this.setupConnectionHandlers(ws, clientInfo);\n        \n        // Send welcome message\n        this.sendToClient(connectionId, {\n            type: 'welcome',\n            connectionId,\n            serverTime: Date.now()\n        });\n    }\n\n    /**\n     * Setup WebSocket message and event handlers\n     */\n    setupConnectionHandlers(ws, clientInfo) {\n        const { id: connectionId } = clientInfo;\n\n        // Handle incoming messages\n        ws.on('message', async (data) => {\n            try {\n                await this.handleMessage(connectionId, data);\n            } catch (error) {\n                logger.error('WebSocket message handling error', {\n                    connectionId,\n                    error\n                });\n                \n                this.sendToClient(connectionId, {\n                    type: 'error',\n                    message: 'Message processing error'\n                });\n            }\n        });\n\n        // Handle connection close\n        ws.on('close', (code, reason) => {\n            this.handleDisconnection(connectionId, code, reason);\n        });\n\n        // Handle connection errors\n        ws.on('error', (error) => {\n            logger.error('WebSocket client error', {\n                connectionId,\n                error\n            });\n        });\n\n        // Handle pong responses for heartbeat\n        ws.on('pong', () => {\n            if (this.clients.has(connectionId)) {\n                this.clients.get(connectionId).lastPong = Date.now();\n            }\n        });\n    }\n\n    /**\n     * Handle incoming WebSocket messages\n     */\n    async handleMessage(connectionId, data) {\n        const client = this.clients.get(connectionId);\n        if (!client) return;\n\n        let message;\n        try {\n            message = JSON.parse(data.toString());\n        } catch (error) {\n            this.sendToClient(connectionId, {\n                type: 'error',\n                message: 'Invalid JSON format'\n            });\n            return;\n        }\n\n        this.stats.totalMessages++;\n\n        // Handle different message types\n        switch (message.type) {\n            case 'authenticate':\n                await this.handleAuthentication(connectionId, message);\n                break;\n\n            case 'subscribe':\n                await this.handleSubscription(connectionId, message);\n                break;\n\n            case 'unsubscribe':\n                await this.handleUnsubscription(connectionId, message);\n                break;\n\n            case 'join_room':\n                await this.handleJoinRoom(connectionId, message);\n                break;\n\n            case 'leave_room':\n                await this.handleLeaveRoom(connectionId, message);\n                break;\n\n            case 'ping':\n                this.sendToClient(connectionId, { type: 'pong' });\n                break;\n\n            case 'task_status_request':\n                await this.handleTaskStatusRequest(connectionId, message);\n                break;\n\n            default:\n                this.sendToClient(connectionId, {\n                    type: 'error',\n                    message: 'Unknown message type'\n                });\n        }\n    }\n\n    /**\n     * Handle client authentication\n     */\n    async handleAuthentication(connectionId, message) {\n        const client = this.clients.get(connectionId);\n        if (!client) return;\n\n        const { token } = message;\n        if (!token) {\n            this.sendToClient(connectionId, {\n                type: 'auth_error',\n                message: 'Token required'\n            });\n            return;\n        }\n\n        try {\n            const decoded = jwt.verify(token, this.config.jwtSecret);\n            \n            client.authenticated = true;\n            client.userId = decoded.userId || decoded.id;\n            client.userEmail = decoded.email;\n            client.userRole = decoded.role || 'user';\n\n            // Track user connections\n            if (!this.userConnections.has(client.userId)) {\n                this.userConnections.set(client.userId, new Set());\n            }\n            this.userConnections.get(client.userId).add(connectionId);\n\n            this.sendToClient(connectionId, {\n                type: 'auth_success',\n                userId: client.userId,\n                role: client.userRole\n            });\n\n            logger.info('WebSocket client authenticated', {\n                connectionId,\n                userId: client.userId,\n                role: client.userRole\n            });\n\n        } catch (error) {\n            logger.warn('WebSocket authentication failed', {\n                connectionId,\n                error: error.message\n            });\n\n            this.sendToClient(connectionId, {\n                type: 'auth_error',\n                message: 'Invalid token'\n            });\n        }\n    }\n\n    /**\n     * Handle subscription to updates\n     */\n    async handleSubscription(connectionId, message) {\n        const client = this.clients.get(connectionId);\n        if (!client) return;\n\n        const { channel, taskId } = message;\n        \n        // Validate subscription permissions\n        if (!this.canSubscribe(client, channel, taskId)) {\n            this.sendToClient(connectionId, {\n                type: 'subscription_error',\n                message: 'Subscription not allowed'\n            });\n            return;\n        }\n\n        const subscriptionKey = taskId ? `${channel}:${taskId}` : channel;\n        client.subscriptions.add(subscriptionKey);\n\n        this.sendToClient(connectionId, {\n            type: 'subscribed',\n            channel,\n            taskId\n        });\n\n        logger.debug('Client subscribed', {\n            connectionId,\n            userId: client.userId,\n            subscription: subscriptionKey\n        });\n    }\n\n    /**\n     * Check if client can subscribe to channel\n     */\n    canSubscribe(client, channel, taskId) {\n        // Public channels\n        const publicChannels = ['system', 'stats', 'announcements'];\n        if (publicChannels.includes(channel)) {\n            return true;\n        }\n\n        // Require authentication for other channels\n        if (!client.authenticated) {\n            return false;\n        }\n\n        // User-specific channels\n        if (channel === 'tasks' && taskId) {\n            // In production, check if user owns the task\n            return true;\n        }\n\n        // Admin channels\n        if (channel === 'admin' && client.userRole === 'admin') {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Send task update notification\n     */\n    notifyTaskUpdate(taskId, update) {\n        const notification = {\n            type: 'task_update',\n            taskId,\n            ...update,\n            timestamp: Date.now()\n        };\n\n        // Send to all clients subscribed to this task\n        this.broadcastToSubscribers(`tasks:${taskId}`, notification);\n        \n        // Also send to task owner if they're subscribed to general tasks\n        if (update.userId) {\n            this.broadcastToUser(update.userId, notification);\n        }\n\n        logger.debug('Task update broadcast', {\n            taskId,\n            updateType: update.status || 'unknown'\n        });\n    }\n\n    /**\n     * Broadcast message to all subscribers of a channel\n     */\n    broadcastToSubscribers(subscriptionKey, message) {\n        let sent = 0;\n        \n        for (const [connectionId, client] of this.clients) {\n            if (client.subscriptions.has(subscriptionKey)) {\n                this.sendToClient(connectionId, message);\n                sent++;\n            }\n        }\n\n        return sent;\n    }\n\n    /**\n     * Send message to all connections of a specific user\n     */\n    broadcastToUser(userId, message) {\n        const userConnections = this.userConnections.get(userId);\n        if (!userConnections) return 0;\n\n        let sent = 0;\n        for (const connectionId of userConnections) {\n            if (this.clients.has(connectionId)) {\n                this.sendToClient(connectionId, message);\n                sent++;\n            }\n        }\n\n        return sent;\n    }\n\n    /**\n     * Send message to specific client\n     */\n    sendToClient(connectionId, message) {\n        const client = this.clients.get(connectionId);\n        if (!client || client.ws.readyState !== WebSocket.OPEN) {\n            return false;\n        }\n\n        try {\n            client.ws.send(JSON.stringify(message));\n            return true;\n        } catch (error) {\n            logger.error('Failed to send WebSocket message', {\n                connectionId,\n                error\n            });\n            return false;\n        }\n    }\n\n    /**\n     * Handle client disconnection\n     */\n    handleDisconnection(connectionId, code, reason) {\n        const client = this.clients.get(connectionId);\n        if (!client) return;\n\n        // Remove from user connections\n        if (client.userId && this.userConnections.has(client.userId)) {\n            this.userConnections.get(client.userId).delete(connectionId);\n            if (this.userConnections.get(client.userId).size === 0) {\n                this.userConnections.delete(client.userId);\n            }\n        }\n\n        // Remove from rooms\n        for (const roomId of client.rooms) {\n            if (this.rooms.has(roomId)) {\n                this.rooms.get(roomId).delete(connectionId);\n                if (this.rooms.get(roomId).size === 0) {\n                    this.rooms.delete(roomId);\n                    this.stats.roomsCount--;\n                }\n            }\n        }\n\n        // Remove client\n        this.clients.delete(connectionId);\n        this.stats.activeConnections--;\n\n        const duration = Date.now() - client.connectedAt;\n        \n        logger.info('WebSocket client disconnected', {\n            connectionId,\n            userId: client.userId,\n            code,\n            reason: reason?.toString(),\n            duration,\n            activeConnections: this.stats.activeConnections\n        });\n    }\n\n    /**\n     * Setup heartbeat mechanism\n     */\n    setupHeartbeat() {\n        setInterval(() => {\n            const now = Date.now();\n            \n            for (const [connectionId, client] of this.clients) {\n                const timeSinceLastPong = now - client.lastPong;\n                \n                // Remove dead connections\n                if (timeSinceLastPong > this.config.pongTimeout + this.config.pingInterval) {\n                    logger.debug('Removing dead WebSocket connection', {\n                        connectionId,\n                        timeSinceLastPong\n                    });\n                    \n                    client.ws.terminate();\n                    this.handleDisconnection(connectionId, 1001, 'Heartbeat timeout');\n                    continue;\n                }\n                \n                // Send ping\n                if (now - client.lastPing > this.config.pingInterval) {\n                    if (client.ws.readyState === WebSocket.OPEN) {\n                        client.ws.ping();\n                        client.lastPing = now;\n                    }\n                }\n            }\n        }, this.config.pingInterval);\n    }\n\n    /**\n     * Generate unique connection ID\n     */\n    generateConnectionId() {\n        return 'ws_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n    }\n\n    /**\n     * Get WebSocket statistics\n     */\n    getStatistics() {\n        return {\n            ...this.stats,\n            roomsCount: this.rooms.size,\n            userConnectionsCount: this.userConnections.size,\n            uptime: process.uptime()\n        };\n    }\n\n    /**\n     * Cleanup dead connections and empty rooms\n     */\n    cleanup() {\n        let cleaned = 0;\n        \n        // Clean up dead connections\n        for (const [connectionId, client] of this.clients) {\n            if (client.ws.readyState === WebSocket.CLOSED || \n                client.ws.readyState === WebSocket.CLOSING) {\n                this.handleDisconnection(connectionId, 1001, 'Cleanup');\n                cleaned++;\n            }\n        }\n        \n        // Clean up empty rooms\n        for (const [roomId, connections] of this.rooms) {\n            if (connections.size === 0) {\n                this.rooms.delete(roomId);\n                this.stats.roomsCount--;\n            }\n        }\n\n        if (cleaned > 0) {\n            logger.debug('WebSocket cleanup completed', {\n                cleanedConnections: cleaned,\n                activeConnections: this.stats.activeConnections\n            });\n        }\n    }\n\n    /**\n     * Shutdown WebSocket server\n     */\n    async shutdown() {\n        logger.info('Shutting down WebSocket server');\n        \n        // Close all client connections\n        for (const [connectionId, client] of this.clients) {\n            client.ws.close(1001, 'Server shutdown');\n        }\n        \n        // Close WebSocket server\n        if (this.wss) {\n            this.wss.close();\n        }\n        \n        this.clients.clear();\n        this.rooms.clear();\n        this.userConnections.clear();\n    }\n}\n\n// Export singleton instance\nlet wsManager = null;\n\nfunction createWebSocketManager(options) {\n    if (!wsManager) {\n        wsManager = new RealtimeWebSocketManager(options);\n    }\n    return wsManager;\n}\n\nfunction getWebSocketManager() {\n    if (!wsManager) {\n        wsManager = new RealtimeWebSocketManager();\n    }\n    return wsManager;\n}\n\nmodule.exports = {\n    RealtimeWebSocketManager,\n    createWebSocketManager,\n    getWebSocketManager\n};